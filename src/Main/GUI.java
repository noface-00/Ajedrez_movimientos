/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Main;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;


/**
 *
 * @author mkevi
 */
public class GUI extends javax.swing.JFrame {
    static JButton[][] matrizBotones;
    boolean peoncheck=false;
    boolean alfilcheck=false;
    
    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();
        inicializarMatrizBotones();
           Color color1 = Color.WHITE; // Color de la primera casilla
            Color color2 = Color.BLACK; // Color de la segunda casilla

            for (int f = 0; f < 8; f++) {
           for (int c = 0; c < 8; c++) {
             // Omitir cambiar el color de A2
             if (!(f == 0 && c == 1)) {
            // Determina el color basado en la paridad de la suma de f y c
            if ((f + c) % 2 == 0) {
                matrizBotones[f][c].setBackground(color1); // Casilla de color 1
            } else {
                matrizBotones[f][c].setBackground(color2); // Casilla de color 2
                B8.setBackground(Color.BLACK);
                }
                 }
            }
            }   
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        Tablero = new javax.swing.JPanel();
        A8 = new javax.swing.JButton();
        B8 = new javax.swing.JButton();
        C8 = new javax.swing.JButton();
        D8 = new javax.swing.JButton();
        E8 = new javax.swing.JButton();
        F8 = new javax.swing.JButton();
        G8 = new javax.swing.JButton();
        H8 = new javax.swing.JButton();
        A7 = new javax.swing.JButton();
        B7 = new javax.swing.JButton();
        C7 = new javax.swing.JButton();
        D7 = new javax.swing.JButton();
        E7 = new javax.swing.JButton();
        F7 = new javax.swing.JButton();
        G7 = new javax.swing.JButton();
        H7 = new javax.swing.JButton();
        A6 = new javax.swing.JButton();
        B6 = new javax.swing.JButton();
        C6 = new javax.swing.JButton();
        D6 = new javax.swing.JButton();
        E6 = new javax.swing.JButton();
        F6 = new javax.swing.JButton();
        F5 = new javax.swing.JButton();
        G6 = new javax.swing.JButton();
        H6 = new javax.swing.JButton();
        A5 = new javax.swing.JButton();
        B5 = new javax.swing.JButton();
        C5 = new javax.swing.JButton();
        D5 = new javax.swing.JButton();
        E5 = new javax.swing.JButton();
        G5 = new javax.swing.JButton();
        H5 = new javax.swing.JButton();
        A4 = new javax.swing.JButton();
        B4 = new javax.swing.JButton();
        C4 = new javax.swing.JButton();
        D4 = new javax.swing.JButton();
        E4 = new javax.swing.JButton();
        F4 = new javax.swing.JButton();
        G4 = new javax.swing.JButton();
        H4 = new javax.swing.JButton();
        A3 = new javax.swing.JButton();
        B3 = new javax.swing.JButton();
        C3 = new javax.swing.JButton();
        D3 = new javax.swing.JButton();
        E3 = new javax.swing.JButton();
        F3 = new javax.swing.JButton();
        G3 = new javax.swing.JButton();
        H3 = new javax.swing.JButton();
        A2 = new javax.swing.JButton();
        B2 = new javax.swing.JButton();
        C2 = new javax.swing.JButton();
        D2 = new javax.swing.JButton();
        E2 = new javax.swing.JButton();
        F2 = new javax.swing.JButton();
        G2 = new javax.swing.JButton();
        H2 = new javax.swing.JButton();
        A1 = new javax.swing.JButton();
        B1 = new javax.swing.JButton();
        C1 = new javax.swing.JButton();
        D1 = new javax.swing.JButton();
        E1 = new javax.swing.JButton();
        F1 = new javax.swing.JButton();
        G1 = new javax.swing.JButton();
        H1 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        Fichas = new javax.swing.JComboBox<>();
        ChkBoxColor = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        Tablero.setLayout(new java.awt.GridLayout(8, 8));
        Tablero.add(A8);
        Tablero.add(B8);
        Tablero.add(C8);
        Tablero.add(D8);
        Tablero.add(E8);
        Tablero.add(F8);
        Tablero.add(G8);

        H8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                H8ActionPerformed(evt);
            }
        });
        Tablero.add(H8);
        Tablero.add(A7);
        Tablero.add(B7);
        Tablero.add(C7);

        D7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                D7ActionPerformed(evt);
            }
        });
        Tablero.add(D7);
        Tablero.add(E7);
        Tablero.add(F7);

        G7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                G7ActionPerformed(evt);
            }
        });
        Tablero.add(G7);
        Tablero.add(H7);
        Tablero.add(A6);
        Tablero.add(B6);
        Tablero.add(C6);
        Tablero.add(D6);
        Tablero.add(E6);
        Tablero.add(F6);
        Tablero.add(F5);

        G6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                G6ActionPerformed(evt);
            }
        });
        Tablero.add(G6);
        Tablero.add(H6);
        Tablero.add(A5);
        Tablero.add(B5);
        Tablero.add(C5);
        Tablero.add(D5);
        Tablero.add(E5);
        Tablero.add(G5);
        Tablero.add(H5);
        Tablero.add(A4);
        Tablero.add(B4);
        Tablero.add(C4);
        Tablero.add(D4);
        Tablero.add(E4);
        Tablero.add(F4);
        Tablero.add(G4);
        Tablero.add(H4);
        Tablero.add(A3);
        Tablero.add(B3);
        Tablero.add(C3);
        Tablero.add(D3);
        Tablero.add(E3);
        Tablero.add(F3);

        G3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                G3ActionPerformed(evt);
            }
        });
        Tablero.add(G3);
        Tablero.add(H3);
        Tablero.add(A2);
        Tablero.add(B2);
        Tablero.add(C2);
        Tablero.add(D2);
        Tablero.add(E2);
        Tablero.add(F2);
        Tablero.add(G2);
        Tablero.add(H2);
        Tablero.add(A1);
        Tablero.add(B1);
        Tablero.add(C1);
        Tablero.add(D1);
        Tablero.add(E1);
        Tablero.add(F1);
        Tablero.add(G1);
        Tablero.add(H1);

        getContentPane().add(Tablero, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 440, 410));

        jPanel1.setBackground(new java.awt.Color(255, 128, 36));

        jLabel1.setFont(new java.awt.Font("Yu Gothic", 2, 18)); // NOI18N
        jLabel1.setText("Piezas de ajedrez");

        Fichas.setBackground(new java.awt.Color(255, 153, 102));
        Fichas.setFont(new java.awt.Font("Yu Gothic Medium", 1, 12)); // NOI18N
        Fichas.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "None", "Peon ", "Alfil", "Caballo", "Torre", "Dama", "Rey", " ", " " }));
        Fichas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FichasActionPerformed(evt);
            }
        });

        ChkBoxColor.setFont(new java.awt.Font("Yu Gothic Medium", 1, 14)); // NOI18N
        ChkBoxColor.setText("Cambiar color");
        ChkBoxColor.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ChkBoxColorActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(Fichas, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(ChkBoxColor, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(0, 40, Short.MAX_VALUE)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Fichas, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(27, 27, 27)
                .addComponent(ChkBoxColor, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(440, 0, 220, 410));

        pack();
    }// </editor-fold>//GEN-END:initComponents
        
   
    public GUI(JButton A1, JButton A2, JButton A3, JButton A4, JButton A5, JButton A6, JButton A7, JButton A8, JButton B1, JButton B2, JButton B3, JButton B4, JButton B5, JButton B6, JButton B7, JButton B8, JButton C1, JButton C2, JButton C3, JButton C4, JButton C5, JButton C6, JButton C7, JButton C8, JButton D1, JButton D2, JButton D3, JButton D4, JButton D5, JButton D6, JButton D7, JButton D8, JButton E1, JButton E2, JButton E3, JButton E4, JButton E5, JButton E6, JButton E7, JButton E8, JButton F1, JButton F2, JButton F3, JButton F4, JButton F5, JButton F6, JButton F7, JButton F8, JComboBox<String> Fichas, JButton G1, JButton G2, JButton G3, JButton G4, JButton G5, JButton G6, JButton G7, JButton G8, JButton H1, JButton H2, JButton H3, JButton H4, JButton H5, JButton H6, JButton H7, JButton H8, JPanel Tablero, JLabel jLabel1) throws HeadlessException {
        this.A1 = A1;
        this.A2 = A2;
        this.A3 = A3;
        this.A4 = A4;
        this.A5 = A5;
        this.A6 = A6;
        this.A7 = A7;
        this.A8 = A8;
        this.B1 = B1;
        this.B2 = B2;
        this.B3 = B3;
        this.B4 = B4;
        this.B5 = B5;
        this.B6 = B6;
        this.B7 = B7;
        this.B8 = B8;
        this.C1 = C1;
        this.C2 = C2;
        this.C3 = C3;
        this.C4 = C4;
        this.C5 = C5;
        this.C6 = C6;
        this.C7 = C7;
        this.C8 = C8;
        this.D1 = D1;
        this.D2 = D2;
        this.D3 = D3;
        this.D4 = D4;
        this.D5 = D5;
        this.D6 = D6;
        this.D7 = D7;
        this.D8 = D8;
        this.E1 = E1;
        this.E2 = E2;
        this.E3 = E3;
        this.E4 = E4;
        this.E5 = E5;
        this.E6 = E6;
        this.E7 = E7;
        this.E8 = E8;
        this.F1 = F1;
        this.F2 = F2;
        this.F3 = F3;
        this.F4 = F4;
        this.F5 = F5;
        this.F6 = F6;
        this.F7 = F7;
        this.F8 = F8;
        this.Fichas = Fichas;
        this.G1 = G1;
        this.G2 = G2;
        this.G3 = G3;
        this.G4 = G4;
        this.G5 = G5;
        this.G6 = G6;
        this.G7 = G7;
        this.G8 = G8;
        this.H1 = H1;
        this.H2 = H2;
        this.H3 = H3;
        this.H4 = H4;
        this.H5 = H5;
        this.H6 = H6;
        this.H7 = H7;
        this.H8 = H8;
        this.Tablero = Tablero;
        this.jLabel1 = jLabel1;
    }
  
    
 /*Inicializa la matriz de botones que representa el tablero*/
private void inicializarMatrizBotones() {
    matrizBotones = new JButton[8][8]; // Matriz de botones de 8x8 para el tablero
    Component[] componentes = Tablero.getComponents(); // Obtiene los componentes del contenedor Tablero
    int index = 0;
    
    // Recorre cada fila y columna para asignar los botones y sus ActionListener
    for (int fila = 0; fila < 8; fila++) {
        for (int columna = 0; columna < 8; columna++) {
            matrizBotones[fila][columna] = (JButton) componentes[index]; // Asigna el botón correspondiente
            index++;
            
            
            final int f = fila; // Fila final para ActionListener
            final int c = columna; // Columna final para ActionListener
            
            // ActionListener para cada botón que resalta los movimientos de la pieza seleccionada
            matrizBotones[fila][columna].addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    System.out.println("Boton en fila " + f + ", columna " + c + " fue pulsado.");
                    String pieza = (String) Fichas.getSelectedItem(); // Obtiene el tipo de pieza seleccionada
                    resaltarMovimientos(pieza, f, c); // Resalta los movimientos posibles para esa pieza en esa posición
                }
            });
        }
    }
}
/*Muestra los movimientos validos de cada ficha*/
private void resaltarMovimientos(String pieza, int fila, int columna) {
    
    Color color1 = Color.WHITE; // Color de la primera casilla
Color color2 = Color.BLACK; // Color de la segunda casilla

for (int f = 0; f < 8; f++) {
    for (int c = 0; c < 8; c++) {
        // Omitir cambiar el color de A2
        if (!(f == 0 && c == 1)) {
            // Determina el color basado en la paridad de la suma de f y c
            if ((f + c) % 2 == 0) {
                matrizBotones[f][c].setBackground(color1); // Casilla de color 1
            } else {
                matrizBotones[f][c].setBackground(color2); // Casilla de color 2
                B8.setBackground(Color.BLACK);
            }
        }
    }
}
    
    int[][] movimientos = new int[0][2]; //matriz para almacenar los movimientos posibles
    
     //De acuerdo a la pieza seleccionada valida sus movimientos
    switch(pieza) {
        case "Dama":
            
            movimientos = dama_mov(new String[8][8], fila, columna);
            break;
        case "Peon":
            movimientos = peon_mov(new String[8][8], fila, columna, false, 0);
            break;
        case "Caballo":
            movimientos = caballo_mov(new String[8][8], fila, columna);
            break;
        case "Alfil":
           if (alfilcheck) { // Si alfilcheck es true, mover el alfil blanco
            movimientos = alfil_mov(new String[8][8], fila, columna, Color.WHITE, Color.WHITE);
        } else { // Si alfilcheck es false, mover el alfil negro
            movimientos = alfil_mov(new String[8][8], fila, columna, Color.WHITE, Color.BLACK);
        }
        break;
        
        case "Rey":
            movimientos = rey_mov(new String[8][8], fila, columna);
            break;
        case "Torre":
            movimientos = torre_mov(new String[8][8], fila, columna);
            break;
    }
    
     //Muestra los movimientos pintando en verde los botones disponibles
    for (int[] movimiento : movimientos) {
        matrizBotones[movimiento[0]][movimiento[1]].setBackground(Color.GREEN);
    }
}

    private void FichasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FichasActionPerformed
        resetearBotones();
    }//GEN-LAST:event_FichasActionPerformed

    private void D7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_D7ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_D7ActionPerformed

    private void G7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_G7ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_G7ActionPerformed

    private void G6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_G6ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_G6ActionPerformed

    private void G3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_G3ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_G3ActionPerformed

    private void H8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_H8ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_H8ActionPerformed

    private void ChkBoxColorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ChkBoxColorActionPerformed
         // Obtiene el estado actual del JCheckBox
    boolean seleccionado = ChkBoxColor.isSelected();
    
    // Actualiza la variable booleana según el estado del JCheckBox
     alfilcheck = seleccionado;
     peoncheck=seleccionado;
    }//GEN-LAST:event_ChkBoxColorActionPerformed

  public static int[][] alfil_mov(String[][] tablero, int fila, int columna, Color colorCasilla, Color colorAlfil) {
    // Direcciones en las que puede moverse el alfil: diagonalmente en las cuatro direcciones
    int[][] direcciones = { { -1, -1 }, { -1, 1 }, { 1, -1 }, { 1, 1 } };
    
    // Matriz para almacenar todos los posibles movimientos del alfil, inicialmente con capacidad máxima
    int[][] movimientos = new int[64][2];
    int count = 0; // Contador de movimientos válidos
    
    // Para cada dirección diagonal posible
    for (int[] direccion : direcciones) {
        int f = fila;
        int c = columna;

        // Avanza en la dirección mientras los movimientos sean válidos dentro del tablero
        while (true) {
            f += direccion[0];
            c += direccion[1];
            
            // Verifica si la nueva posición está dentro de los límites del tablero
            if (f >= 0 && f < 8 && c >= 0 && c < 8) {
                // Verificar si la casilla es del color adecuado para el alfil
                boolean casillaValida = (f + c) % 2 == 0 ? colorAlfil.equals(Color.WHITE) : colorAlfil.equals(Color.BLACK);
                
                if (casillaValida) {
                    // Si la casilla está vacía (null), es un movimiento válido
                    if (tablero[f][c] == null) {
                        movimientos[count][0] = f;
                        movimientos[count][1] = c;
                        count++;
                    } else {

                        break; // Si encuentra una pieza enemiga o aliada, se detiene en esa dirección
                    }
                } else {

                    break; // Si la casilla no es del color correcto para el alfil, se detiene en esa dirección
                }
            } else {

                break; // Si se sale de los límites del tablero, se detiene en esa dirección
            }
        }
    }
    
    // Crea una matriz de movimientos válidos con el tamaño exacto necesario
    int[][] movimientos_validos = new int[count][2];
    
    // Copia los movimientos válidos encontrados al arreglo de tamaño exacto
    for (int i = 0; i < count; i++) {
        movimientos_validos[i][0] = movimientos[i][0];
        movimientos_validos[i][1] = movimientos[i][1];
    }
    
    return movimientos_validos; // Devuelve la matriz de movimientos válidos del alfil
}


public static int[][] caballo_mov(String[][] tablero, int fila, int columna) {
    // Direcciones de los saltos posibles del caballo
    int[][] direcciones_saltos = {
        {-2, -1}, {-2, 1}, // Dos filas arriba y una columna a la izquierda/derecha
        {2, -1}, {2, 1},   // Dos filas abajo y una columna a la izquierda/derecha
        {-1, -2}, {-1, 2}, // Una fila arriba/abajo y dos columnas a la izquierda/derecha
        {1, -2}, {1, 2}    // Una fila abajo/arriba y dos columnas a la izquierda/derecha
    };
    
    // Matriz para almacenar todos los posibles movimientos del caballo, inicialmente con capacidad máxima
    int[][] movimientos = new int[64][2];
    int count = 0; // Contador de movimientos válidos
    
    // Para cada dirección de salto posible del caballo
    for (int[] direccion : direcciones_saltos) {
        int f = fila;
        int c = columna;

        // Calcula la nueva posición después del salto
        f += direccion[0];
        c += direccion[1];
        
        // Verifica si la nueva posición está dentro de los límites del tablero y es una casilla vacía
        if (f >= 0 && f < 8 && c >= 0 && c < 8 && tablero[f][c] == null) {
            // Almacena el movimiento válido en la matriz de movimientos
            movimientos[count][0] = f;
            movimientos[count][1] = c;
            count++;
        }
    }
    
    // Crea una matriz de movimientos válidos con el tamaño exacto necesario
    int[][] movimientos_validos = new int[count][2];
    
    // Copia los movimientos válidos encontrados al arreglo de tamaño exacto
    for (int i = 0; i < count; i++) {
        movimientos_validos[i][0] = movimientos[i][0];
        movimientos_validos[i][1] = movimientos[i][1];
    }
    
    return movimientos_validos; // Devuelve la matriz de movimientos válidos del caballo
}

 public static int[][] torre_mov(String[][] tablero, int fila, int columna) {
    // Direcciones en las que puede moverse la torre (vertical y horizontal)
    int[][] direcciones = {
        {-1, 0}, // Arriba
        {0, 1},  // Derecha
        {0, -1}, // Izquierda
        {1, 0}   // Abajo
    };
    
    // Matriz para almacenar todos los posibles movimientos de la torre, inicialmente con capacidad máxima
    int[][] movimientos = new int[64][2];
    int count = 0; // Contador de movimientos válidos
    
    // Para cada dirección de movimiento posible de la torre
    for (int[] direccion : direcciones) {
        int f = fila;
        int c = columna;

        // Mueve en la dirección actual mientras esté dentro de los límites del tablero
        while (true) {
            f += direccion[0];
            c += direccion[1];
            
            // Verifica si la nueva posición está dentro de los límites del tablero y es una casilla vacía
            if (f >= 0 && f < 8 && c >= 0 && c < 8) {
                if (tablero[f][c] == null) {
                    // Almacena el movimiento válido en la matriz de movimientos
                    movimientos[count][0] = f;
                    movimientos[count][1] = c;
                    count++;
                } else {
                    break; // Rompe el bucle si encuentra una pieza en la trayectoria
                }
            } else {
                break; // Rompe el bucle si se sale de los límites del tablero
            }
        }
    }
    
    // Crea una matriz de movimientos válidos con el tamaño exacto necesario
    int[][] movimientos_validos = new int[count][2];
    
    // Copia los movimientos válidos encontrados al arreglo de tamaño exacto
    for (int i = 0; i < count; i++) {
        movimientos_validos[i][0] = movimientos[i][0];
        movimientos_validos[i][1] = movimientos[i][1];
    }
    
    return movimientos_validos; // Devuelve la matriz de movimientos válidos de la torre
}

 public static int[][] dama_mov(String[][] tablero, int fila, int columna) {
    // Direcciones en las que puede moverse la dama (diagonales y rectas)
    int[][] direcciones = {
        {-1, -1}, // Diagonal superior izquierda
        {-1, 1},  // Diagonal superior derecha
        {1, -1},  // Diagonal inferior izquierda
        {1, 1},   // Diagonal inferior derecha
        {-1, 0},  // Arriba
        {0, 1},   // Derecha
        {0, -1},  // Izquierda
        {1, 0}    // Abajo
    };
    
    // Matriz para almacenar todos los posibles movimientos de la dama, inicialmente con capacidad máxima
    int[][] movimientos = new int[64][2];
    int count = 0; // Contador de movimientos válidos
    
    // Para cada dirección de movimiento posible de la dama
    for (int[] direccion : direcciones) {
        int f = fila;
        int c = columna;

        // Mueve en la dirección actual mientras esté dentro de los límites del tablero
        while (true) {
            f += direccion[0];
            c += direccion[1];
            
            // Verifica si la nueva posición está dentro de los límites del tablero y es una casilla vacía
            if (f >= 0 && f < 8 && c >= 0 && c < 8) {
                if (tablero[f][c] == null) {
                    // Almacena el movimiento válido en la matriz de movimientos
                    movimientos[count][0] = f;
                    movimientos[count][1] = c;
                    count++;
                } else {
                    break; // Rompe el bucle si encuentra una pieza en la trayectoria
                }
            } else {
                break; // Rompe el bucle si se sale de los límites del tablero
            }
        }
    }
    
    // Crea una matriz de movimientos válidos con el tamaño exacto necesario
    int[][] movimientos_validos = new int[count][2];
    
    // Copia los movimientos válidos encontrados al arreglo de tamaño exacto
    for (int i = 0; i < count; i++) {
        movimientos_validos[i][0] = movimientos[i][0];
        movimientos_validos[i][1] = movimientos[i][1];
    }
    
    return movimientos_validos; // Devuelve la matriz de movimientos válidos de la dama
}

 public static int[][] rey_mov(String[][] tablero, int fila, int columna) {
    // Direcciones en las que puede moverse el rey (diagonales y rectas)
    int[][] direcciones = {
        {-1, -1}, // Diagonal superior izquierda
        {-1, 1},  // Diagonal superior derecha
        {1, -1},  // Diagonal inferior izquierda
        {1, 1},   // Diagonal inferior derecha
        {-1, 0},  // Arriba
        {0, 1},   // Derecha
        {0, -1},  // Izquierda
        {1, 0}    // Abajo
    };
    
    // Matriz para almacenar todos los posibles movimientos del rey, inicialmente con capacidad máxima
    int[][] movimientos = new int[64][2];
    int count = 0; // Contador de movimientos válidos
    
    // Para cada dirección de movimiento posible del rey
    for (int[] direccion : direcciones) {
        int f = fila;
        int c = columna;

        // Mueve en la dirección actual mientras esté dentro de los límites del tablero
        while (true) {
            f += direccion[0];
            c += direccion[1];
            
            // Verifica si la nueva posición está dentro de los límites del tablero y es una casilla vacía
            if (f >= 0 && f < 8 && c >= 0 && c < 8) {
                if (tablero[f][c] == null) {
                    // Almacena el movimiento válido en la matriz de movimientos
                    movimientos[count][0] = f;
                    movimientos[count][1] = c;
                    count++;
                    break;
                } else {
                    break; // Rompe el bucle si encuentra una pieza en la trayectoria
                }
            } else {
                break; // Rompe el bucle si se sale de los límites del tablero
            }
        }
    }
    
    // Crea una matriz de movimientos válidos con el tamaño exacto necesario
    int[][] movimientos_validos = new int[count][2];
    
    // Copia los movimientos válidos encontrados al arreglo de tamaño exacto
    for (int i = 0; i < count; i++) {
        movimientos_validos[i][0] = movimientos[i][0];
        movimientos_validos[i][1] = movimientos[i][1];
    }
    
    return movimientos_validos; // Devuelve la matriz de movimientos válidos del rey
}


public static int[][] peon_mov(String[][] tablero, int row, int col ,boolean init, int C_ficha) {
    // Definir las direcciones posibles para un peón (una hacia arriba y otra hacia abajo)
    int[][] direcciones = { { -1, 0 }, { 1, 0 } };
    // Arreglo para almacenar los movimientos posibles
    int[][] movimientos = new int[64][2];
    int count = 0;
    int inicio_f = 0;

    int fila = row;
    int columna = col;
    int cont=0;

    // Asegurarse de que C_ficha es un índice válido
    if (C_ficha < 0 || C_ficha >= direcciones.length) {
        throw new IllegalArgumentException("C_ficha debe ser 0 o 1");
    }

    // Obtener la dirección basada en el valor de C_ficha
    int[] direccion = direcciones[C_ficha];

    while (true) {
        fila += direccion[0];
        columna += direccion[1];

        // Verificar si la nueva posición está dentro del tablero
        if (fila >= 0 && fila < 8 && columna >= 0 && columna < 8) {
            // Verificar si la posición está vacía
            if (tablero[fila][columna] == null) {
                movimientos[count][0] = fila;
                movimientos[count][1] = columna;
                count++;

                // Si es el movimiento inicial y no ha excedido los dos movimientos iniciales
                if (init && inicio_f < 1) {
                    inicio_f++;
                } else {
                    break;
                }
            } else {
                break;
            }
        } else {
            break;
        }
    }

    // Crear un arreglo ajustado al número de movimientos encontrados
    int[][] movimientos_v = new int[count][2];
    for (int i = 0; i < count; i++) {
        movimientos_v[i][0] = movimientos[i][0];
        movimientos_v[i][1] = movimientos[i][1];
    }

    return movimientos_v;
}





    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {    

        
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);

            }
        });
    }
    private void resetearBotones() {
        Color color1 = Color.WHITE; // Color de la primera casilla
Color color2 = Color.BLACK; // Color de la segunda casilla

for (int f = 0; f < 8; f++) {
    for (int c = 0; c < 8; c++) {
        // Omitir cambiar el color de A2
        if (!(f == 0 && c == 1)) {
            // Determina el color basado en la paridad de la suma de f y c
            if ((f + c) % 2 == 0) {
                matrizBotones[f][c].setBackground(color1); // Casilla de color 1
            } else {
                matrizBotones[f][c].setBackground(color2); // Casilla de color 2
                B8.setBackground(Color.BLACK);
            }
        }
    }
}
}
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton A1;
    private javax.swing.JButton A2;
    private javax.swing.JButton A3;
    private javax.swing.JButton A4;
    private javax.swing.JButton A5;
    private javax.swing.JButton A6;
    private javax.swing.JButton A7;
    private javax.swing.JButton A8;
    private javax.swing.JButton B1;
    private javax.swing.JButton B2;
    private javax.swing.JButton B3;
    private javax.swing.JButton B4;
    private javax.swing.JButton B5;
    private javax.swing.JButton B6;
    private javax.swing.JButton B7;
    private javax.swing.JButton B8;
    private javax.swing.JButton C1;
    private javax.swing.JButton C2;
    private javax.swing.JButton C3;
    private javax.swing.JButton C4;
    private javax.swing.JButton C5;
    private javax.swing.JButton C6;
    private javax.swing.JButton C7;
    private javax.swing.JButton C8;
    private javax.swing.JCheckBox ChkBoxColor;
    private javax.swing.JButton D1;
    private javax.swing.JButton D2;
    private javax.swing.JButton D3;
    private javax.swing.JButton D4;
    private javax.swing.JButton D5;
    private javax.swing.JButton D6;
    private javax.swing.JButton D7;
    private javax.swing.JButton D8;
    private javax.swing.JButton E1;
    private javax.swing.JButton E2;
    private javax.swing.JButton E3;
    private javax.swing.JButton E4;
    private javax.swing.JButton E5;
    private javax.swing.JButton E6;
    private javax.swing.JButton E7;
    private javax.swing.JButton E8;
    private javax.swing.JButton F1;
    private javax.swing.JButton F2;
    private javax.swing.JButton F3;
    private javax.swing.JButton F4;
    private javax.swing.JButton F5;
    private javax.swing.JButton F6;
    private javax.swing.JButton F7;
    private javax.swing.JButton F8;
    private javax.swing.JComboBox<String> Fichas;
    private javax.swing.JButton G1;
    private javax.swing.JButton G2;
    private javax.swing.JButton G3;
    private javax.swing.JButton G4;
    private javax.swing.JButton G5;
    private javax.swing.JButton G6;
    private javax.swing.JButton G7;
    private javax.swing.JButton G8;
    private javax.swing.JButton H1;
    private javax.swing.JButton H2;
    private javax.swing.JButton H3;
    private javax.swing.JButton H4;
    private javax.swing.JButton H5;
    private javax.swing.JButton H6;
    private javax.swing.JButton H7;
    private javax.swing.JButton H8;
    private javax.swing.JPanel Tablero;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables
}
